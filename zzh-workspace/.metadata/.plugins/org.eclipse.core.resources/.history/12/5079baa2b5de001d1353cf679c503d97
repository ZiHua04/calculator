package StackMethod;
public class StackMethod{
    public static void main(String[] args) {
        String expression = "1*2+3*4/2-6+15";
        Stack numstack = new Stack(20);
        Stack operstack = new Stack(20);
        char ch = ' ';      //存放当前扫描到的值
        int index = 0;      //用于遍历扫描栈
        int num1 = 0;
        int num2 = 0;
        int opera = 0;
        int res = 0;
        String joint = "";      //用于拼接多位数

        while(true){
            //依次获取表达式字符串的每一个字符
            ch = expression.substring(index,index+1).charAt(0);     //将获取到的字符串转成一个字符
            //判断ch类型
            if(operstack.isOpera(ch)){
                //判断符号栈是否为空
                if(!operstack.isEmpty()){
                    //若符号栈不为空则判断当前符号与栈顶元素符号优先级
                    if(operstack.priority(ch) <= operstack.priority(operstack.gettop())){
                        num1 = numstack.pop();
                        num2 = numstack.pop();
                        opera = operstack.pop();
                        res = numstack.cal(num1,num2,opera);    //计算当前运算结果
                        //将运算结果入数栈，当前运算符入符号栈
                        numstack.add(res);
                        operstack.add(ch);
                    } else{
                        operstack.add(ch);      //直接将当前符号入符号栈
                    }
                }else{
                    operstack.add(ch);      //符号栈为空则直接将当前符号入符号栈
                }
            }else{//若当前扫描值为数,直接入数栈
                //判断是否为多位数，当扫描到一个数时，不立即入栈，继续向后扫描，当扫描到符号时才入栈
                joint = joint+ch;
                if(index == expression.length()-1){
                    //若当前已扫描到字符串的最后一位，则直接入栈
                    numstack.add(Integer.parseInt(joint));      //将字符串转换成整型数据入栈
                }else{
                    //判断下一位是否为符号
                    if(operstack.isOpera(expression.substring(index+1,index+2).charAt(0))){
                        numstack.add(Integer.parseInt(joint));      //将字符串转换成整型数据入栈
                        joint = "";     //初始化joint
                    }
                }
            }
            index++;
            if(index >= expression.length()){
                break;
            }
        }

        //表达式字符串扫描完毕，循环取出栈中元素进行运算
        while (true){
            if(operstack.isEmpty()){        //若符号栈为空，则数栈中只有一个值，即为运算结果
                break;
            }
            num1 = numstack.pop();
            num2 = numstack.pop();
            opera = operstack.pop();
            res = numstack.cal(num1,num2,opera);
            numstack.add(res);
        }
        int finres = numstack.pop();        //将数栈中最后一个元素取出，即为运算结果
        System.out.println(expression +"="+ finres);

    }
}

//建立栈信息类
class Stack{

    private int maxsize;        //定义栈数组最大容量
    private int[] stack;        //定义栈数组
    private int top = -1;       //定义栈顶元素指针
    //栈构造器
    public Stack(int maxsize){
        this.maxsize = maxsize;
        stack = new int[maxsize];
    }

    //获取当前栈顶元素
    public int gettop(){
        return stack[top];
    }

    //判断是否栈空
    public boolean isEmpty(){
        return top == -1;
    }

    //判断是否栈满
    public boolean isFull(){
        return top == maxsize - 1;
    }

    //元素入栈
    public void add(int value){
        //判断是否栈满
        if(isFull()){
            System.out.println("栈满，无法入栈");
            return;
        }
        top++;
        stack[top] = value;
    }

    //元素出栈
    public int pop(){
        //判断是否栈空
        if(isEmpty()){
            throw new RuntimeException("栈空");
        }
        int value = stack[top];
        top--;
        return value;       //返回出栈元素值
    }

    //遍历打印栈所有元素
    public void list(){
        if(isEmpty()){
            System.out.println("栈空，没有数据");
            return;
        }
        //从栈顶开始遍历打印
        for(int i = top;i<=0;i--){
            System.out.println(stack[top]+" ");
        }
    }

    //返回运算符优先级
    public int priority(int operator){
        if(operator =='*' || operator == '/')
            return 1;
        if(operator =='+' || operator == '-')
            return 0;
        else
            return -1;
    }

    //判断是否为运算符
    public boolean isOpera(int val){
        return val == '+' || val == '-' || val == '*' || val == '/';
    }

    //计算方法
    public int cal(int num1,int num2,int opera){
        int res = 0;  //存放计算结果
        switch (opera){
            case '+':
                res = num1 + num2;
                break;
            case '-':
                if(num1 > num2)
                    res = num1 - num2;
                else
                    res = num2 - num1;
                break;
            case '*':
                res = num1 * num2;
                break;
            case '/':
                if(num1 > num2)
                    res = num1 / num2;
                else
                    res = num2 / num1;
                break;
            default:
                break;
        }
        return res;
    }

}
